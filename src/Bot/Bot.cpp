#include "Bot.h"

const char BOT_FILE_PATH[] = { "" };
const float MOVE_SPEED = 5.0f;
const float SPERE_R = 5.0f;

#define DEG_TO_RAD(a)	((a) * DX_PI_F / 180.0f)	//ラジアン角に変換する式

//コンストラクタ
CBot::CBot()
{
	tmp_dir = 0;
	tmp_Range = 0;
	State_Id = STATE_NUM;
}

//デストラクタ
CBot::~CBot()
{
	State_Id = STATE_NUM;
}

//初期化
void CBot::Init()
{
	CObject::Init();
	cPos = VGet(0.0f, 10.0f, 100.0f);
	cSize = VGet(1.0f, 1.0f, 1.0f);
	cRotate = VGet(0.0f, 0.0f, 0.0f);

	tmp = 0;

	State_Id = STATE_NUM;
}

//読み込み
bool CBot::Load()
{
	iHndl = MV1LoadModel(BOT_FILE_PATH);
	State_Id = STATE_STOP;

	if (iHndl != -1)
		return true;
	else
		return false;
}

//描画
void CBot::Draw()
{
	//条件式がtrueならモデルをfalseなら球を表示
	if (iHndl != -1)
	{
		MV1DrawModel(iHndl);
	}
	else
	{
		DrawSphere3D(cPos, SPERE_R, 32, GetColor(255, 0, 0), GetColor(255, 0, 0), TRUE);
	}

	DrawFormatString(0, 150, GetColor(0, 0, 0), "ボットX座標:%f", cPos.x);
	DrawFormatString(0, 165, GetColor(0, 0, 0), "ボットY座標:%f", cPos.y);
	DrawFormatString(0, 180, GetColor(0, 0, 0), "ボットZ座標:%f", cPos.z);
	DrawFormatString(0, 195, GetColor(0, 0, 0), "外積:%f", tmp_dir);
	DrawFormatString(0, 210, GetColor(0, 0, 0), "距離:%f", tmp_Range);

}

//マイフレーム行う処理
void CBot::Step(vector<VECTOR> List)
{
	

	switch (State_Id)
	{
	case CBot::STATE_STOP:

		//テスト用処理
		if (CInput::IsKeyPush(KEY_INPUT_1))
		{
			//Idを変更する
			State_Id = STATE_MOVE;
		}
		break;

	case CBot::STATE_MOVE:

		Move_Bot(List);	//追尾処理
		break;

	default:
		break;
	}
	
	//更新処理
	Update();
}


//指定の場所に動く処理
void CBot::Move_Bot(vector<VECTOR> List)
{
	//ボットから指定の地点へ行くベクトルを計算
	VECTOR Vtmp;
	Vtmp.x = List[tmp].x - cPos.x;
	Vtmp.y = 0.0f;
	Vtmp.z = List[tmp].z - cPos.z;

	//進行方向のどちら側にいるのかを調べる
	float Dir = 0.0f;

	VECTOR vSpd = VGet(0.0f, 0.0f, 0.0f);	//ボットの移動ベクトル
	vSpd.x = sinf(cRotate.y) * -MOVE_SPEED;
	vSpd.y = 0.0f;
	vSpd.z = cosf(cRotate.y) * -MOVE_SPEED;

	//外積計算
	Dir = Vtmp.x * vSpd.z - vSpd.x * Vtmp.z;
	//確認用
	tmp_dir = Dir;

	//回転する角度を決める
	if (Dir >= 0.0f)
	{
		cRotate.y += 0.01f;
	}
	else if (Dir < 0.0f)
	{
		cRotate.y -= 0.01f;
	}

	//座標に速度を加算する
	cPos.x += sinf(cRotate.y) * -0.2f;
	cPos.z += cosf(cRotate.y) * -0.2f;

	//プレイヤーとの距離を計算
	float Range = (List[tmp].x - cPos.x) * (List[tmp].x - cPos.x) + (List[tmp].z - cPos.z) * (List[tmp].z - cPos.z);
	Range = sqrt(Range);
	//確認用
	tmp_Range = Range;

	//距離が一定値に達したらIdを変更する
	if (Range < 0.1f)
	{
		tmp++;
		
		//もう一度計算しなおす
		Vtmp.x = List[tmp].x - cPos.x;
		Vtmp.y = 0.0f;
		Vtmp.z = List[tmp].z - cPos.z;

		vSpd.x = sinf(cRotate.y) * -MOVE_SPEED;
		vSpd.y = 0.0f;
		vSpd.z = cosf(cRotate.y) * -MOVE_SPEED;

		//外積計算
		Dir = Vtmp.x * vSpd.z - vSpd.x * Vtmp.z;

		//アークタンジェントで角度を出す
		//float NextRot = atan2

		if (Dir >= 0.0f)
		{
			//プラス方向へ
		}
		else
		{
			//マイナス方向へ

		}

		if (tmp == List.size())
		{
			State_Id = STATE_STOP;
			tmp = 0;
		}
	}
}

//経路探索
void CBot::Route_Search(VECTOR GoalPos)
{
	//引数の小さい順に上(奥),下(手前),右,左,右上,右下,左上,左下

	Search_info.Distance += 50.0f;

	//スタートからの距離を求める
	Search_info.Range_From_Start[0] = 1.0f;
	Search_info.Range_From_Start[1] = 1.0f;
	Search_info.Range_From_Start[2] = 1.0f;
	Search_info.Range_From_Start[3] = 1.0f;
	Search_info.Range_From_Start[4] = 1.0f;
	Search_info.Range_From_Start[5] = 1.0f;
	Search_info.Range_From_Start[6] = 1.0f;
	Search_info.Range_From_Start[7] = 1.0f;

	//動いた地点からゴールまでの直線距離を求める
	/*for (int Index = 0; Index < 8; Index++)
	{

	}*/
	Search_info.Renge_To_Goal[0] = hypot((GoalPos.x - cPos.x), (GoalPos.z - (cPos.z + Search_info.Distance)));	//上
	Search_info.Renge_To_Goal[1] = hypot((GoalPos.x - cPos.x), (GoalPos.z - (cPos.z - Search_info.Distance)));	//下
	Search_info.Renge_To_Goal[2] = hypot((GoalPos.x - (cPos.x + Search_info.Distance)), (GoalPos.z - cPos.z));	//右
	Search_info.Renge_To_Goal[3] = hypot((GoalPos.x - (cPos.x - Search_info.Distance)), (GoalPos.z - cPos.z));	//左
	Search_info.Renge_To_Goal[4] = hypot((GoalPos.x - (cPos.x + Search_info.Distance)), (GoalPos.z - (cPos.z + Search_info.Distance)));	//右上
	Search_info.Renge_To_Goal[5] = hypot((GoalPos.x - (cPos.x + Search_info.Distance)), (GoalPos.z - (cPos.z - Search_info.Distance)));	//右下
	Search_info.Renge_To_Goal[6] = hypot((GoalPos.x - (cPos.x - Search_info.Distance)), (GoalPos.z - (cPos.z + Search_info.Distance)));	//左上
	Search_info.Renge_To_Goal[7] = hypot((GoalPos.x - (cPos.x - Search_info.Distance)), (GoalPos.z - (cPos.z - Search_info.Distance)));	//左下

	//合計距離の最小を求める
	for (int Index = 0; Index < 8; Index++)
	{
		Search_info.Total_Renge[Index] = Search_info.Range_From_Start[Index] + Search_info.Renge_To_Goal[Index];
		
		if (Index == 0)
		{
			Search_info.Min_Total_Renge = Search_info.Total_Renge[0];
		}
		else
		{
			if (Search_info.Total_Renge[Index] < Search_info.Min_Total_Renge)
			{
				Search_info.Min_Total_Renge = Search_info.Total_Renge[Index];
				//最小の場所の値を格納する
				//現在のCenter_Posに離れた座標分を足す
				Search_info.Center_Pos = VGet(cPos.x, 0.0f, cPos.z);
			}
		}
	}

	
}

